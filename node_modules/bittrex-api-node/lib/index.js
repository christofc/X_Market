/**
 * Bittrex API for Node.js
 *
 * @version 0.0.1
 * @copyright Vadim Malykhin 2018
 * @link https://github.com/VadimMalykhin/bittrex-api-node
 * @tutorial https://bittrex.github.io/
 * @tutorial https://bittrex.com/Home/Api
 */
const Promise = require('bluebird');
const Request = require('request-promise');
const Signalr = require('signalr-client');
const Jsonic = require('jsonic');
const HmacSHA512 = require('crypto-js/hmac-sha512');
const Querystring = require('querystring');
const Zlib = require('zlib');
const Chalk = require('chalk');
const _ = require('lodash');

/**
 * Constants
 */
const ENDPOINT_V1 = 'https://bittrex.com/api/v1.1';
const ENDPOINT_V2 = 'https://bittrex.com/api/v2.0';
const ENDPOINT_WS = 'wss://socket.bittrex.com/signalr';
const ENDPOINT_WS_BETA = 'wss://beta.bittrex.com/signalr';

const TICKINTERVAL_ONEMIN = 'oneMin';
const TICKINTERVAL_FIVEMIN = 'fiveMin';
const TICKINTERVAL_THIRTYMIN = 'thirtyMin';
const TICKINTERVAL_HOUR = 'hour';
const TICKINTERVAL_DAY = 'day';

const ORDERTYPE_LIMIT = 'LIMIT';
const ORDERTYPE_MARKET = 'MARKET';

const TIMEINEFFECT_GOOD_TIL_CANCELLED = 'GOOD_TIL_CANCELLED';
const TIMEINEFFECT_IMMEDIATE_OR_CANCEL = 'IMMEDIATE_OR_CANCEL';
const TIMEINEFFECT_FILL_OR_KILL = 'FILL_OR_KILL';

const CONDITIONTYPE_NONE = 'NONE';
const CONDITIONTYPE_GREATER_THAN = 'GREATER_THAN';
const CONDITIONTYPE_LESS_THAN = 'LESS_THAN';
const CONDITIONTYPE_STOP_LOSS_FIXED = 'STOP_LOSS_FIXED';
const CONDITIONTYPE_STOP_LOSS_PERCENTAGE = 'STOP_LOSS_PERCENTAGE';

const MESSAGE_APIKEY_INVALID = 'APIKEY_INVALID';
const MESSAGE_INVALID_PERMISSION = 'INVALID_PERMISSION';
const MESSAGE_MARKET_NOTPROVIDED = 'MARKET_NOT_PROVIDED';
const MESSAGE_INVALID_MARKET = 'INVALID_MARKET';
const MESSAGE_ADDRESS_GENERATING = 'ADDRESS_GENERATING';

const WEBSOCKET_MAIN_HUB = 'c2';

const WEBSOCKET_BALANCE_DELTA = 'uB';
const WEBSOCKET_MARKET_DELTA = 'uE';
const WEBSOCKET_SUMMARY_LITE_DELTA = 'uL';
const WEBSOCKET_ORDER_DELTA = 'uO';
const WEBSOCKET_SUMMARY_DELTA = 'uS';

const WEBSOCKET_QUERY_SUMMARY_STATE = 'QuerySummaryState';
const WEBSOCKET_SUBSCRIBE_TO_EXCHANGE_DELTAS = 'SubscribeToExchangeDeltas';
const WEBSOCKET_SUBSCRIBE_TO_SUMMARY_DELTAS = 'SubscribeToSummaryDeltas';
const WEBSOCKET_SUBSCRIBE_TO_SUMMARY_LITE_DELTAS = 'SubscribeToSummaryLiteDeltas';
const WEBSOCKET_QUERY_EXCHANGE_STATE = 'QueryExchangeState';
const WEBSOCKET_GET_AUTH_CONTENT = 'GetAuthContext';
const WEBSOCKET_AUTHENTICATE = 'Authenticate';

const WEBSOCKET_ORDER_DELTA_OPEN = 0;
const WEBSOCKET_ORDER_DELTA_PARTIAL = 1;
const WEBSOCKET_ORDER_DELTA_FILL = 2;
const WEBSOCKET_ORDER_DELTA_CANCEL = 3;

/**
 * Bittrex Api Node
 *
 * @param {object=} [options] Required parameter.
 * @return {object}
 */
module.exports = (options) => {
  // merging defaults with options
  options = _.merge({
    publicKey: '',
    secretKey: '',
    request: {
      method: 'GET',
      headers: {
        'User-Agent': 'Request-Promise',
        'Content-type': 'application/x-www-form-urlencoded',
      },
      json: true,
      resolveWithFullResponse: true,
      timeout: 20000,
    },
    websocket: {
      endpoint: ENDPOINT_WS,
      hubs: [WEBSOCKET_MAIN_HUB],
      reconnect: 5000, // timeout between trying to reconnect or false to disable auto reconnect after disconnect
      keysMap: {},
      callbacks: {},
    },
    verbose: false,
  }, options);

  // minified JSON Keys
  const keysMap = _.assign({
    A: 'Ask',
    a: 'Available',
    B: 'Bid',
    b: 'Balance',
    C: 'Closed',
    c: 'Currency',
    CI: 'CancelInitiated',
    D: 'Deltas',
    d: 'Delta',
    DT: 'OrderDeltaType',
    E: 'Exchange',
    e: 'ExchangeDeltaType',
    F: 'FillType',
    FI: 'FillId',
    f: 'Fills',
    G: 'OpenBuyOrders',
    g: 'OpenSellOrders',
    H: 'High',
    h: 'AutoSell',
    I: 'Id',
    i: 'IsOpen',
    J: 'Condition',
    j: 'ConditionTarget',
    K: 'ImmediateOrCancel',
    k: 'IsConditional',
    L: 'Low',
    l: 'Last',
    M: 'MarketName',
    m: 'BaseVolume',
    N: 'Nonce',
    n: 'CommissionPaid',
    O: 'Orders',
    o: 'Order',
    OT: 'OrderType',
    OU: 'OrderUuid',
    P: 'Price',
    p: 'CryptoAddress',
    PD: 'PrevDay',
    PU: 'PricePerUnit',
    Q: 'Quantity',
    q: 'QuantityRemaining',
    R: 'Rate',
    r: 'Requested',
    S: 'Sells',
    s: 'Summaries',
    T: 'TimeStamp',
    t: 'Total',
    TY: 'Type',
    U: 'Uuid',
    u: 'Updated',
    V: 'Volume',
    W: 'AccountId',
    w: 'AccountUuid',
    X: 'Limit',
    x: 'Created',
    Y: 'Opened',
    y: 'State',
    Z: 'Buys',
    z: 'Pending',
  }, options.keysMap);

  /**
   * Console.log wrapper
   *
   * @private
   */
  const log = {
    info: (...args) => { if (options.verbose) console.info(...args); },
    warn: (...args) => { if (options.verbose) console.warn(...args); },
    error: (...args) => { if (options.verbose) console.error(...args); },
  };

  /**
   * Remove an empty objects recursively
   *
   * @private
   * @param {object} [object]
   * @return {object}
   */
  const cleanObject = object => (_.isObject(object) ? _.pickBy(object, v => v !== null && v !== undefined && v !== '') : object);

  /**
   * Replace object keys recursively
   *
   * @private
   * @param {object} [obj]
   * @return {object}
   */
  const replaceObjectKeys = obj => _.transform(obj, (result, value, key) => {
    const currentKey = keysMap[key] || key;
    result[currentKey] = _.isObject(value) ? replaceObjectKeys(value) : value;
  });

  /**
   * Create signature
   *
   * @private
   * @param {string} [challenge]
   * @param {string} [secret]
   * @return {string}
   */
  const createSignature = (challenge, secret) => HmacSHA512(challenge, secret).toString();

  /**
   * Decode a message
   *
   * @param {string} [base64]
   * @param {Function} [callback]
   * @return {Promise}
   */
  const decodeMessage = base64 => new Promise((resolve, reject) => {
    const raw = new Buffer.from(base64, 'base64');
    Zlib.inflateRaw(raw, (error, inflated) => {
      if (!error) {
        resolve(replaceObjectKeys(Jsonic(inflated.toString('utf8'))));
      } else {
        reject(error);
      }
    });
  });

  /**
   * Send request
   *
   * @private
   * @param {string} [uri]
   * @param {object=} [params]
   * @return {Promise}
   */
  const sendRequest = (uri, params) => new Promise((resolve, reject) => {
    if (!uri) {
      reject(new Error('URI not provided.'));
    } else {
      params = params || {};

      const nonce = (new Date()).getTime();

      let qs = (!params.qs) ? {} : cleanObject(params.qs);
      let requestOptions;

      if (!params.withCredentials) {
        qs = _.assign(qs, { _: nonce });
        requestOptions = _.assign(options.request, { uri, qs });
      } else {
        qs = _.assign(qs, { apikey: options.publicKey, nonce });
        requestOptions = _.assign(options.request, { uri, qs, headers: { apisign: createSignature(`${uri}?${Querystring.stringify(qs)}`, options.secretKey) } });
      }

      const now = Date.now();
      const url = uri + (qs ? `?${Querystring.stringify(qs)}` : '');

      log.info('%s receiving `%s`', Chalk.yellow('∞'), url);

      Request(requestOptions)
        .then((response) => {
          if (!response.body || !response.body.success || +response.statusCode !== 200) {
            log.error('%s received error: %s', Chalk.red('✗'), response.body.message);
            reject(new Error(response.body.message));
          } else {
            log.info('%s received `%s` in %d sec.', Chalk.green('✓'), url, (Date.now() - now) / 1000);
            resolve(response.body);
          }
        })
        .catch((error) => {
          log.error('%s received error: %s', Chalk.red('✗'), error);
          reject(error);
        });
    }
  });

  return {
    /**
     * Get Bitcoin price in USD
     *
     * @return {Promise}
     */
    getBTCPrice: () => sendRequest(`${ENDPOINT_V2}/pub/currencies/GetBTCPrice`),

    /**
     * Get Ethereum price in USD
     *
     * @return {Promise}
     */
    getETHPrice: () => sendRequest(`${ENDPOINT_V1}/public/getticker`, { qs: { market: 'USDT-ETH' } }),

    /**
     * Get the current tick values for a market
     *
     * @param {string=} [market] Required parameter.
     * @return {Promise}
     */
    getTicker: market => sendRequest(`${ENDPOINT_V1}/public/getticker`, { qs: { market } }),

    /**
     * Get the chart data
     *
     * @param {string} [marketname]   - Required parameter.
     * @param {string} [tickInterval] - Required parameter. Use TICKINTERVAL constants.
     * @return {Promise}
     */
    getTicks: (marketname, tickInterval) => new Promise((resolve, reject) =>
      sendRequest(`${ENDPOINT_V2}/pub/market/GetTicks`, { qs: { marketname, tickInterval } })
        .then((result) => {
          result = replaceObjectKeys(result);
          resolve(result);
        })
        .catch(error => reject(error))),

    /**
     * Get the open and available trading markets at Bittrex along with other meta data
     *
     * @param {object} [params] Required parameter.
     * @return {Promise}
     */
    getMarkets: params => sendRequest(`${ENDPOINT_V1}/public/getmarkets`, params),

    /**
     * Get all supported currencies at Bittrex along with other meta data
     *
     * @return {Promise}
     */
    getCurrencies: () => sendRequest(`${ENDPOINT_V2}/pub/currencies/getcurrencies`),

    /**
     * Get the last 24 hour summary of all active markets
     *
     * @return {Promise}
     */
    getMarketSummaries: () => sendRequest(`${ENDPOINT_V2}/pub/markets/getmarketsummaries`),

    /**
     * Get the last 24 hour summary of a specific market
     *
     * @param {string} [marketname] Required parameter.
     * @return {Promise}
     */
    getMarketSummary: marketname => sendRequest(`${ENDPOINT_V2}/pub/market/getmarketsummary`, { qs: { marketname } }),

    /**
     * Retrieve the latest trades that have occurred for a specific market
     *
     * @param {string} [market] Required parameter. A string literal for the market (ex: BTC-LTC).
     * @return {Promise}
     */
    getMarketHistory: market => sendRequest(`${ENDPOINT_V1}/public/getmarkethistory`, { qs: { market } }),

    /**
     * Get retrieve the orderbook for a given market
     *
     * @param {string} [marketname] Required parameter. A string literal for the market (ex: BTC-LTC).
     * @return {Promise}
     */
    getOrderBook: marketname => sendRequest(`${ENDPOINT_V2}/pub/market/getmarketorderbook`, { qs: { marketname } }),

    /**
     * Get the wallet health
     *
     * @return {Promise}
     */
    getWalletHealth: () => sendRequest(`${ENDPOINT_V2}/pub/currencies/getwallethealth`),

    /**
     * Retrieve all balances from your account
     *
     * @return {Promise}
     */
    getBalances: () => sendRequest(`${ENDPOINT_V2}/key/balance/getbalances`, { withCredentials: true }),

    /**
     * Retrieve the balance from your account for a specific currency
     *
     * @param {string} [currencyname] Required parameter.
     * @return {Promise}
     */
    getBalance: currencyname => sendRequest(`${ENDPOINT_V2}/key/balance/getbalance`, { qs: { currencyname }, withCredentials: true }),

    /**
     * Retrieve the pending withdrawals from your account
     *
     * @param {string=} [currencyname] - Optional parameter.
     * @return {Promise}
     */
    getPendingWithdrawals: currencyname => sendRequest(`${ENDPOINT_V2}/key/balance/getpendingwithdrawals`, { qs: { currencyname }, withCredentials: true }),

    /**
     * Retrieve the withdrawal history from your account
     *
     * @param {string=} [currencyname] - Optional parameter.
     * @return {Promise}
     */
    getWithdrawalHistory: currencyname => sendRequest(`${ENDPOINT_V2}/key/balance/getwithdrawalhistory`, { qs: { currencyname }, withCredentials: true }),

    /**
     * Retrieve the pending deposits from your account
     *
     * @param {string=} [currency] - Optional parameter.
     * @return {Promise}
     */
    getPendingDeposits: currency => sendRequest(`${ENDPOINT_V2}/key/balance/getpendingdeposits`, { qs: { currency }, withCredentials: true }),

    /**
     * Retrieve the deposit history from your account
     *
     * @param currency
     * @return {Promise}
     */
    getDepositHistory: currency => sendRequest(`${ENDPOINT_V2}/key/balance/getdeposithistory`, { qs: { currency }, withCredentials: true }),

    /**
     * Retrieve or generate an address for a specific currency
     *
     * If one does not exist, the call will fail and return ADDRESS_GENERATING until one is available.
     *
     * @param {string} [currencyname]
     * @return {Promise}
     */
    getDepositAddress: currencyname => sendRequest(`${ENDPOINT_V2}/key/balance/getdepositaddress`, { qs: { currencyname }, withCredentials: true }),

    /**
     * Generate a new deposit address
     *
     * @param {string} [currency] Required parameter.
     * @return {Promise}
     */
    generateDepositAddress: currency => sendRequest(`${ENDPOINT_V2}/key/balance/generatedepositaddress`, { qs: { currency }, withCredentials: true }),

    /**
     * Get all orders that you currently have opened
     *
     * @param {string} [marketname] Optional parameter.
     * @return {Promise}
     */
    getOpenOrders: marketname => (marketname ?
      sendRequest(`${ENDPOINT_V2}/key/market/getopenorders`, { qs: { marketname }, withCredentials: true }) :
      sendRequest(`${ENDPOINT_V2}/key/orders/getopenorders`, { withCredentials: true })),

    /**
     * Retrieve your order history
     *
     * @param marketname
     * @return {Promise}
     */
    getOrderHistory: marketname => (marketname ?
      sendRequest(`${ENDPOINT_V2}/key/market/getorderhistory`, { qs: { marketname }, withCredentials: true }) :
      sendRequest(`${ENDPOINT_V2}/key/orders/getorderhistory`, { withCredentials: true })),

    /**
     * Place a buy order in a specific market
     *
     * @param {string} [marketname] Required parameter.
     * @param {string} [ordertype] Required parameter.
     * @param [number} [quantity] Required parameter.
     * @param [number} [rate] Required parameter.
     * @param [string} [timeInEffect] Required parameter.
     * @param [string} [conditiontype] Required parameter.
     * @param {number} [target] Required parameter.
     * @return {Promise}
     */
    tradeBuy: (marketname, ordertype, quantity, rate, timeInEffect, conditiontype, target) => { // eslint-disable-line
      // todo
      log.info('tradeBuy', ...arguments);
    },

    /**
     * Place an sell order in a specific market
     *
     * @param {string} [marketname] Required parameter.
     * @param {string} [ordertype] Required parameter.
     * @param [number} [quantity] Required parameter.
     * @param [number} [rate] Required parameter.
     * @param [string} [timeInEffect] Required parameter.
     * @param [string} [conditiontype] Required parameter.
     * @param {number} [target] Required parameter.
     * @return {Promise}
     */
    tradeSell: (marketname, ordertype, quantity, rate, timeInEffect, conditiontype, target) => { // eslint-disable-line
      // todo
      log.info('tradeSell', ...arguments);
    },

    /**
     * Cancel a buy or sell order
     *
     * @param {string} [marketname] Required parameter.
     * @param {string} [orderid] Required parameter.
     * @return {Promise}
     */
    tradeCancel: (marketname, orderid) => sendRequest(`${ENDPOINT_V2}/key/market/tradecancel`, { qs: { marketname, orderid }, withCredentials: true }),

    /**
     * Withdraw funds from your account
     *
     * @param {string} [currency] Required parameter. A string literal for the market (ie. BTC-LTC)
     * @param {string} [quantity] Required parameter. The quantity of coins to withdraw.
     * @param {string} [address] Required parameter. The address where to send the funds.
     * @param {string} [paymentid] Optional parameter. Used for CryptoNotes/BitShareX/Nxt/XRP and any other coin that has a memo/message/tag/paymentid option.
     * @return {Promise}
     */
    withdrawCurrency: (currency, quantity, address, paymentid) => sendRequest(`${ENDPOINT_V2}/key/balance/withdrawcurrency`, {
      qs: {
        currency, quantity, address, paymentid,
      },
      withCredentials: true,
    }),

    /**
     * WebSocket
     */
    webSocket: () => {
      // events
      const events = {
        connected: [],
        disconnected: [],
      };

      // received messages callbacks
      const callbacks = _.assign({
        [WEBSOCKET_BALANCE_DELTA]: {},
        [WEBSOCKET_MARKET_DELTA]: {},
        [WEBSOCKET_SUMMARY_LITE_DELTA]: {},
        [WEBSOCKET_ORDER_DELTA]: {},
        [WEBSOCKET_SUMMARY_DELTA]: {},
      }, options.websocket.callbacks);

      // last received message time
      let lastMessageTime = (new Date()).getTime();

      // watch connection
      let watcher;

      // client instance
      let client;

      return {
        /**
         * WebSocket connect
         *
         * @param {Function} [clientCallback]
         * @return {undefined}
         */
        connect(clientCallback) {
          client = new Signalr.client(options.websocket.endpoint, options.websocket.hubs, undefined, true); // eslint-disable-line

          /**
           * Connected
           */
          client.serviceHandlers.connected = (connection) => {
            log.info('%s WebSocket connected', Chalk.green('✓'));

            // call the `connected` events
            if (events.connected.length) {
              _.each(events.connected, event => event(client));
            }

            // add watcher
            if (!watcher && options.websocket.reconnect >= 1000) {
              watcher = setInterval(() => {
                if (connection.state === 'closed') {
                  const diff = (new Date()).getTime() - lastMessageTime;
                  if (diff > 20000) {
                    log.info('%s WebSocket trying to reconnect', Chalk.yellow('∞'));
                    client.start();
                  }
                }
              }, options.websocket.reconnect);
            }

            clientCallback(client);
          };

          /**
           * Disconnected
           */
          client.serviceHandlers.disconnected = () => {
            log.info('%s WebSocket disconnected', Chalk.green('✓'));

            // call the `disconnected` event
            if (events.disconnected.length) {
              _.each(events.disconnected, event => event(client));
            }

            // remove watcher
            if (watcher && !options.websocket.reconnect) {
              // clear watcher
              clearInterval(watcher);
              watcher = null;
            }
          };

          /**
           * On error
           */
          client.serviceHandlers.onerror = (error) => {
            log.error('%s WebSocket error:', Chalk.red('✗'), error);
          };

          /**
           * Message received
           */
          client.serviceHandlers.messageReceived = (message) => {
            lastMessageTime = (new Date()).getTime();
            if (message.type === 'utf8') {
              message = Jsonic(message.utf8Data);
              if (Object.prototype.hasOwnProperty.call(message, 'M') && message.M[0]) {
                const data = message.M[0];
                if (callbacks[data.M] && Object.prototype.hasOwnProperty.call(data, 'A') && data.A[0]) {
                  decodeMessage(data.A[0]).then((json) => {
                    const key = json[keysMap.M] ? json[keysMap.M] : 0;
                    if (Object.prototype.hasOwnProperty.call(callbacks[data.M], key)) {
                      callbacks[data.M][key](json);
                    } else {
                      log.warn('%s callback is not defined for `%s` `%s`', Chalk.red('✗'), data.M, key);
                    }
                  }).catch(error => log.error('%s cannot decode a message', Chalk.red('✗'), error));
                }
              }
            }
          };

          /**
           * Reconnecting
           *
           * @return {boolean}
           */
          client.serviceHandlers.reconnecting = () => true;

          /**
           * Verifies a user’s identity to the server and begins receiving account-level notifications
           *
           * @return {undefined}
           */
          client.authenticate = () => {
            log.info('%s Authenticate', Chalk.yellow('∞'));

            client.call(WEBSOCKET_MAIN_HUB, WEBSOCKET_GET_AUTH_CONTENT, options.publicKey).done((error, result) => {
              if (!error) {
                log.info('%s Authenticated', Chalk.green('✓'));
                client.invoke(WEBSOCKET_MAIN_HUB, WEBSOCKET_AUTHENTICATE, options.publicKey, createSignature(result, options.secretKey));
              } else {
                log.error('%s Authentication error:', Chalk.red('✗'), error);
              }
            });
          };

          /**
           * Allows the caller to retrieve the full order book for a specific market
           *
           * @param {string} [marketName]
           * @param {Function} [cb]
           */
          client.getQueryExchangeState = (marketName, cb) => {
            const method = WEBSOCKET_QUERY_EXCHANGE_STATE;

            log.info('%s Querying to `%s`', Chalk.yellow('∞'), method);

            client.call(WEBSOCKET_MAIN_HUB, method, marketName).done((error, result) => {
              if (!error) {
                if (result) {
                  log.info('%s Queried to `%s`', Chalk.green('✓'), method);
                  decodeMessage(result).then(json => cb(json)).catch(error => log.error('%s cannot decode a message', Chalk.red('✗'), error));
                }
              } else {
                log.error('%s Querying error:', Chalk.red('✗'), error);
              }
            });
          };

          /**
           * Allows the caller to retrieve the full state for all markets
           *
           * @param {Function} [cb]
           */
          client.getQuerySummaryState = (cb) => {
            // todo
            cb();
          };

          /**
           * Allows the caller to receive real-time updates to the state of a single market
           *
           * @param {string} [marketName]
           * @param {Function} [cb]
           */
          client.getExchangeDeltas = (marketName, cb) => {
            const method = WEBSOCKET_SUBSCRIBE_TO_EXCHANGE_DELTAS;

            log.info('%s Subscribing to `%s` `%s`', Chalk.yellow('∞'), method, marketName);

            client.call(WEBSOCKET_MAIN_HUB, method, marketName).done((error, result) => {
              if (!error) {
                if (result) {
                  log.info('%s Subscribed to `%s` `%s`', Chalk.green('✓'), method, marketName);
                  callbacks[WEBSOCKET_MARKET_DELTA][marketName] = cb;
                }
              } else {
                log.error('%s Subscribing to `%s` `%s` has an error:', Chalk.red('✗'), method, marketName, error);
              }
            });
          };

          /**
           * Allows the caller to receive real-time updates of the state of all markets
           *
           * @param {Function} [cb]
           */
          client.getSummaryDeltas = (cb) => {
            const method = WEBSOCKET_SUBSCRIBE_TO_SUMMARY_DELTAS;

            log.info('%s Subscribing to `%s`', Chalk.yellow('∞'), method);

            client.call(WEBSOCKET_MAIN_HUB, method).done((error, result) => {
              if (!error) {
                if (result === true) {
                  log.info('%s Subscribed to `%s`', Chalk.green('✓'), method);
                  callbacks[WEBSOCKET_SUMMARY_DELTA][0] = cb;
                }
              } else {
                log.error('%s Subscribing error:', Chalk.red('✗'), error);
              }
            });
          };

          /**
           * Allows the caller to receive real-time updates of the state of all markets
           *
           * @param {Function} [cb]
           */
          client.getSummaryLiteDeltas = (cb) => {
            const method = WEBSOCKET_SUBSCRIBE_TO_SUMMARY_LITE_DELTAS;

            log.info('%s Subscribing to `%s`', Chalk.yellow('∞'), method);

            client.call(WEBSOCKET_MAIN_HUB, method).done((error, result) => {
              if (!error) {
                if (result === true) {
                  log.info('%s Subscribed to `%s`', Chalk.green('✓'), method);
                  callbacks[WEBSOCKET_SUMMARY_LITE_DELTA][0] = cb;
                }
              } else {
                log.error('%s Subscribing error:', Chalk.red('✗'), error);
              }
            });
          };

          /**
           * Get balances for your account
           *
           * @param {Function} [cb]
           */
          client.getBalanceDelta = (cb) => {
            callbacks[WEBSOCKET_BALANCE_DELTA][0] = cb;
          };

          /**
           * Get orders for your account
           *
           * @param {Function} [cb]
           */
          client.getOrderDelta = (cb) => {
            callbacks[WEBSOCKET_ORDER_DELTA][0] = cb;
          };

          /**
           * WebSocket disconnect
           */
          client.disconnect = () => {
            if (client) {
              log.info('%s WebSocket disconnecting', Chalk.yellow('∞'));

              // connection end
              client.end();
              client = null;

              // reset callbacks
              callbacks[WEBSOCKET_BALANCE_DELTA] = {};
              callbacks[WEBSOCKET_MARKET_DELTA] = {};
              callbacks[WEBSOCKET_SUMMARY_LITE_DELTA] = {};
              callbacks[WEBSOCKET_ORDER_DELTA] = {};
              callbacks[WEBSOCKET_SUMMARY_DELTA] = {};
            }
          };

          // websocket start
          client.start();
        },

        /**
         * Assign callbacks to events
         *
         * @param {string} [eventName]
         * @param {Function} [cb]
         */
        on: (eventName, cb) => {
          if (['connected', 'disconnected'].includes(eventName)) {
            events[eventName].push(cb);
          } else {
            log.error('%s Unknown event name: %s', Chalk.red('✗'), eventName);
          }
        },
      };
    },
  };
};

module.exports.ENDPOINT_V1 = ENDPOINT_V1;
module.exports.ENDPOINT_V2 = ENDPOINT_V2;
module.exports.ENDPOINT_WS = ENDPOINT_WS;
module.exports.ENDPOINT_WS_BETA = ENDPOINT_WS_BETA;

module.exports.TICKINTERVAL_ONEMIN = TICKINTERVAL_ONEMIN;
module.exports.TICKINTERVAL_FIVEMIN = TICKINTERVAL_FIVEMIN;
module.exports.TICKINTERVAL_THIRTYMIN = TICKINTERVAL_THIRTYMIN;
module.exports.TICKINTERVAL_HOUR = TICKINTERVAL_HOUR;
module.exports.TICKINTERVAL_DAY = TICKINTERVAL_DAY;

module.exports.ORDERTYPE_LIMIT = ORDERTYPE_LIMIT;
module.exports.ORDERTYPE_MARKET = ORDERTYPE_MARKET;

module.exports.TIMEINEFFECT_GOOD_TIL_CANCELLED = TIMEINEFFECT_GOOD_TIL_CANCELLED;
module.exports.TIMEINEFFECT_IMMEDIATE_OR_CANCEL = TIMEINEFFECT_IMMEDIATE_OR_CANCEL;
module.exports.TIMEINEFFECT_FILL_OR_KILL = TIMEINEFFECT_FILL_OR_KILL;

module.exports.CONDITIONTYPE_NONE = CONDITIONTYPE_NONE;
module.exports.CONDITIONTYPE_GREATER_THAN = CONDITIONTYPE_GREATER_THAN;
module.exports.CONDITIONTYPE_LESS_THAN = CONDITIONTYPE_LESS_THAN;
module.exports.CONDITIONTYPE_STOP_LOSS_FIXED = CONDITIONTYPE_STOP_LOSS_FIXED;
module.exports.CONDITIONTYPE_STOP_LOSS_PERCENTAGE = CONDITIONTYPE_STOP_LOSS_PERCENTAGE;

module.exports.MESSAGE_APIKEY_INVALID = MESSAGE_APIKEY_INVALID;
module.exports.MESSAGE_INVALID_PERMISSION = MESSAGE_INVALID_PERMISSION;
module.exports.MESSAGE_MARKET_NOTPROVIDED = MESSAGE_MARKET_NOTPROVIDED;
module.exports.MESSAGE_INVALID_MARKET = MESSAGE_INVALID_MARKET;
module.exports.MESSAGE_ADDRESS_GENERATING = MESSAGE_ADDRESS_GENERATING;

module.exports.WEBSOCKET_MAIN_HUB = WEBSOCKET_MAIN_HUB;

module.exports.WEBSOCKET_BALANCE_DELTA = WEBSOCKET_BALANCE_DELTA;
module.exports.WEBSOCKET_MARKET_DELTA = WEBSOCKET_MARKET_DELTA;
module.exports.WEBSOCKET_SUMMARY_LITE_DELTA = WEBSOCKET_SUMMARY_LITE_DELTA;
module.exports.WEBSOCKET_ORDER_DELTA = WEBSOCKET_ORDER_DELTA;
module.exports.WEBSOCKET_SUMMARY_DELTA = WEBSOCKET_SUMMARY_DELTA;

module.exports.WEBSOCKET_QUERY_SUMMARY_STATE = WEBSOCKET_QUERY_SUMMARY_STATE;
module.exports.WEBSOCKET_SUBSCRIBE_TO_EXCHANGE_DELTAS = WEBSOCKET_SUBSCRIBE_TO_EXCHANGE_DELTAS;
module.exports.WEBSOCKET_SUBSCRIBE_TO_SUMMARY_DELTAS = WEBSOCKET_SUBSCRIBE_TO_SUMMARY_DELTAS;
module.exports.WEBSOCKET_SUBSCRIBE_TO_SUMMARY_LITE_DELTAS = WEBSOCKET_SUBSCRIBE_TO_SUMMARY_LITE_DELTAS;
module.exports.WEBSOCKET_QUERY_EXCHANGE_STATE = WEBSOCKET_QUERY_EXCHANGE_STATE;
module.exports.WEBSOCKET_GET_AUTH_CONTENT = WEBSOCKET_GET_AUTH_CONTENT;
module.exports.WEBSOCKET_AUTHENTICATE = WEBSOCKET_AUTHENTICATE;

module.exports.WEBSOCKET_ORDER_DELTA_OPEN = WEBSOCKET_ORDER_DELTA_OPEN;
module.exports.WEBSOCKET_ORDER_DELTA_PARTIAL = WEBSOCKET_ORDER_DELTA_PARTIAL;
module.exports.WEBSOCKET_ORDER_DELTA_FILL = WEBSOCKET_ORDER_DELTA_FILL;
module.exports.WEBSOCKET_ORDER_DELTA_CANCEL = WEBSOCKET_ORDER_DELTA_CANCEL;
